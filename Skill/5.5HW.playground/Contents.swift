//import UIKit
//
//1. Прочитать статью про ООП.
//
//В чем различие между классом и объектом?
//Класс - по сути "скелет" или характеристики/свойства объекта. Объект - непосредственно набор этих характеристик/свойств.
//Например, класс автомобиля содержит в себе описание характеристик автомобиля. А объектом будет конкретный автомобиль, который будет описан с помощью этих характеристик.

//
//
//2. Решить задачу разделения сущностей на классы (используя наследование, где нужно) и протоколы в следующих программах:
//
//в игре есть сундук с инвентарем. Инвентарь — это различные игровые объекты, например: растения, оружие, квестовые предметы — картинка;
class Inventory {
    func addItems() {
        print("Add new auest item")
    }
}
extension Inventory {
    func addPlant() -> String {
        return "Add new plant"
    }
}

//в игре показывается карта с: игроками, монстрами (ими управляет компьютер), интерактивными предметами и неподвижными элементами (например, деревья, стены) — картинка;
class MapWithPlayer {
    func showPlayer() {
        print("Player enter on the map")
    }
    func showTree() {
        print("Tree is on the map")
    }
}
class MapWithMonster: MapWithPlayer {
    override func showPlayer() {
        print("Monster enter on the map")
    }
}
extension MapWithPlayer {
    func showWall() {
        print("Wall is on the map")
    }
}

//у приложения есть 3 модели машин, у каждой из которых есть 3 комплектации. Модели отличаются названием, картинкой. Комплектации — названием, ценой, цветом, объемом двигателя.
class Automobile {
    func printModel() {
        print("Model = *, image = *")
    }
}
class Equipment: Automobile {
    override func printModel() {
        print("Equipment = *, price = *, color = *, engine = *")
    }
}
//В каких случаях лучше использовать наследование, а в каких — расширения (extension)?


//3. Ответить, не используя xcode: что выведется в консоль в результате выполнения следующего кода (если код некорректен, написать, какая строчка и почему не скомпилируется):
//
//<pre>
//
//protocol A{
//
//func a()
//
//}
//
//protocol B{
//
//func b()
//
//}
//
//extension B{
//
//func b(){
//
//print("B")
//
//}
//
//}
//
//class C: A{
//
//func a() {
//
//print("A")
//
//}
//
//func c(){
//
//print("C")
//}
//
//}
//
//class D: C, B{
//
//func b() {
//
//print("B")
//
//}
//
//func d(){
//
//print("D")
//
//}
//
//}
//
//</pre>
//
//
//
//let v1: A = D()
//
//v1.a()
//
//let v2: B = C() // здесь, на сколько я увидел, C имеет только протокол A, но не B
//
//v2.c() // я так понимаю, здесь будет ошибка, т.к. в расширении B нет функции c
//
//let v3: C = D()
//
//v3.d() // и здесь будет ошибка, т.к. в классе C нет  функции d
//
//let v4: D = D()
//
//v4.a()
//
//4. Выучить определения полиморфизма, инкапсуляции и наследования — наверняка об этом спросят на собеседовании! Если их суть не до конца понятна, нужно пересмотреть видео, перечитать статью или написать в Телеграм. Свободно ориентироваться в этих понятиях крайне важно!
//Инкапсуляцию я запомнил еще давно простым способом. In capsule. Сразу понятно, что что-то где-то сокрыто. В тех же классах мы описываем объекты, функции и пр. При создании нового объекта мы видим только свойства объекта и то только то, которые доступны в конкретном пространстве имен.
//Полиморфизм и наследование я постоянно путаю. Помню, что что-то из этого позволяет написать код один раз и дальше переиспользовать его.
//Но погуглив вспоминаю, что наследование - возможность создавать класс на основе другого класса наследуя его свойства и функции (не обязательно все), а также можем переопределять функции наследуемого класса.
//А полиморфизм, соответственно, как я понимаю - написал один раз, а используешь несколько раз.
//Если это не верно, просьба поправить.
